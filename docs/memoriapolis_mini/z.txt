// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\cell.js
// Clase que representa una celda individual
class Cell {
    constructor(i, j, size) {
      this.i = i; // Índice en X
      this.j = j; // Índice en Y
      this.size = size;
      this.x = i * size;
      this.y = j * size;
      this.height = this.generateHeight();
      this.color = this.getColorBasedOnHeight(this.height);
    }
  
    generateHeight() {
      // Utiliza las coordenadas globales para generar la altura
      // Ajuste para suavizar el terreno
      return map(noise(this.i * noiseScale, this.j * noiseScale), 0, 1, minH, maxH);
    }
  
    getColorBasedOnHeight(h) {
      // Definición de los puntos de la escala de colores
      let colorScale = [
        { value: minH, color: color(0, 0, 139) },        // Azul oscuro
        { value: -500, color: color(0, 0, 255) },         // Azul océano
        { value: -200, color: color(135, 206, 235) },     // Azul celeste
        { value: -20, color: color(173, 216, 230) },      // Azul claro
        { value: 0, color: color(255, 255, 224) },        // Amarillo claro
        { value: 40, color: color(154, 205, 50) },        // Amarillo verdoso
        { value: 400, color: color(144, 238, 144) },      // Verde claro
        { value: 900, color: color(34, 139, 34) },        // Verde fresco
        { value: 1500, color: color(0, 100, 0) },         // Verde oscuro
        { value: 1900, color: color(255, 165, 0) },       // Anaranjado montaña
        { value: 2200, color: color(128, 128, 128) },     // Marrón grisáceo
        { value: 2500, color: color(105, 105, 105) },     // Gris
        { value: maxH, color: color(255) }                // Blanco nieve
      ];
  
      // Encontrar los dos puntos entre los cuales se encuentra la altura
      let lower = colorScale[0];
      let upper = colorScale[colorScale.length -1];
  
      for(let i = 0; i < colorScale.length -1; i++) {
        if(h >= colorScale[i].value && h < colorScale[i+1].value) {
          lower = colorScale[i];
          upper = colorScale[i+1];
          break;
        }
      }
  
      // Calcular el porcentaje entre lower y upper
      let pct = map(h, lower.value, upper.value, 0, 1);
      pct = constrain(pct, 0, 1);
  
      // Interpolar entre los dos colores
      return lerpColor(lower.color, upper.color, pct);
    }
  
    display() {
      fill(this.color);
      noStroke();
      rect(this.x, this.y, this.size, this.size);
    }
  }


// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\grid.js
  
  // Clase que representa la grilla
  class Grid {
    constructor(cellSize) {
      this.cellSize = cellSize;
      this.cells = new Map(); // Usamos un Map para almacenar las celdas con claves "i,j"
    }
  
    generateCellsInView(offsetX, offsetY, canvasWidth, canvasHeight) {
      // Determina el rango de celdas que deberían estar visibles
      let startX = -offsetX;
      let startY = -offsetY;
      let endX = startX + canvasWidth;
      let endY = startY + canvasHeight;
  
      let generationMargin = 2; // Margen adicional para generar celdas
      let deletionMargin = 4;   // Margen para eliminar celdas fuera de vista
  
      let startI = Math.floor(startX / this.cellSize) - generationMargin;
      let startJ = Math.floor(startY / this.cellSize) - generationMargin;
      let endI = Math.floor(endX / this.cellSize) + generationMargin;
      let endJ = Math.floor(endY / this.cellSize) + generationMargin;
  
      // Generar celdas necesarias
      for(let i = startI; i <= endI; i++) {
        for(let j = startJ; j <= endJ; j++) {
          this.addCell(i, j);
        }
      }
  
      // Eliminar celdas que están fuera del rango de eliminación
      let deletionStartI = Math.floor(startX / this.cellSize) - deletionMargin;
      let deletionStartJ = Math.floor(startY / this.cellSize) - deletionMargin;
      let deletionEndI = Math.floor(endX / this.cellSize) + deletionMargin;
      let deletionEndJ = Math.floor(endY / this.cellSize) + deletionMargin;
  
      let keysToDelete = [];
      for(let key of this.cells.keys()) {
        let [cellI, cellJ] = key.split(',').map(Number);
        if(cellI < deletionStartI || cellI > deletionEndI || cellJ < deletionStartJ || cellJ > deletionEndJ) {
          keysToDelete.push(key);
        }
      }
  
      // Eliminar las celdas fuera de rango
      for(let key of keysToDelete) {
        this.cells.delete(key);
      }
    }
  
    addCell(i, j) {
      let key = `${i},${j}`;
      if(!this.cells.has(key)) {
        let cell = new Cell(i, j, this.cellSize);
        this.cells.set(key, cell);
      }
    }
  
    display() {
      for(let cell of this.cells.values()) {
        cell.display();
      }
    }
  }

// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\houses.js

class House {
  constructor(points) {
    this.points = points; // Array de puntos que definen el polígono de la casa
    this.color = this.randomBrownColor(); // Genera un color marrón aleatorio
  }

  // Método para dibujar la casa
  display(buffer, offsetX = 0, offsetY = 0) {
    if (!buffer) {
      buffer = window; // Si no se proporciona un buffer, usar el canvas principal
    }
    buffer.fill(this.color);
    buffer.stroke(0);
    buffer.strokeWeight(1);
    buffer.beginShape();
    for (let point of this.points) {
      buffer.vertex(point.X - offsetX, point.Y - offsetY);
    }
    buffer.endShape(CLOSE);
  }

  // Método para obtener el polígono de la casa
  getPolygon() {
    return this.points;
  }

  // Método para generar un color marrón aleatorio
  randomBrownColor() {
    let r = random(60, 190); // Rango de rojos entre marrón claro y oscuro
    let g = random(40, 95); // Rango de verdes para tonos de marrón
    let b = random(0, 100); // Rango de azules para tonos de marrón
    let a = 200; // Transparencia fija

    return color(r, g, b, a);
  }
}

// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\polygon.js
// Polygon.js

// Array of syllables for name generation
const syllables = ['pa', 'ta', 'ma', 'ca', 'ra', 'la', 'sa', 'na', 'ki', 'mi', 'li', 'si', 'ni', 'to', 'mo', 'lo', 'so', 'no'];
const suffixes = ['quirá', 'tiva', 'catá'];

// Clase Polygon que representa una localidad en el simulador
class Polygon {
  constructor(points, color) {
    this.points = points; // Puntos del polígono
    this.color = color; // Color del polígono

    // Generar nombre de la localidad
    let numSyllables = floor(random(1, 4)); // Entre 1 y 4 sílabas
    this.name = '';
    for (let i = 0; i < numSyllables; i++) {
      this.name += random(syllables);
    }
    this.name += random(suffixes);

    this.population = 0; // Población de la localidad
    this.densidad = 0.8;
    this.roads = []; // Array de caminos (segmentos de líneas)
    this.houses = []; // Array de casas
    this.lenPatio=0.5;
    this.spacing = random(30, 60); // Espaciamiento entre caminos paralelos
    this.selected = false; // Estado de selección
    this.ensureClockwise(); // Asegurar orientación clockwise
    this.generateRoads(); // Generar los caminos internos

    // Atributo fundacion para el frame en que se creó
    this.fundacion = frameCount;

    // Crear un buffer gráfico para el polígono
    //this.buffer = createGraphics(width, height);
// Calcular el bounding box del polígono
this.minX = Math.min(...this.points.map(p => p.X));
this.maxX = Math.max(...this.points.map(p => p.X));
this.minY = Math.min(...this.points.map(p => p.Y));
this.maxY = Math.max(...this.points.map(p => p.Y));

// Calcular el tamaño del buffer
let bufferWidth = this.maxX - this.minX;
let bufferHeight = this.maxY - this.minY;

// Crear el buffer con el tamaño adecuado
this.buffer = createGraphics(bufferWidth, bufferHeight);
    // Bandera para indicar si la población cambió
    this.populationChanged = true;
    this.updateBuffer()
  }

  // Método para actualizar el buffer gráfico
  updateBuffer() {
    this.buffer.clear();

    // Dibujar el polígono
    this.buffer.fill(this.color);
    this.buffer.stroke(120);
    this.buffer.strokeWeight(4);
    this.buffer.beginShape();
    for (let point of this.points) {
      this.buffer.vertex(point.X - this.minX, point.Y - this.minY);
    }
    this.buffer.endShape(CLOSE);

    // Dibujar los caminos internos
    this.buffer.stroke(100);
    this.buffer.strokeWeight(3);
    for (let road of this.roads) {
      this.buffer.line(road.start.X- this.minX, road.start.Y- this.minY, road.end.X- this.minX, road.end.Y- this.minY);
    }

    // Dibujar las casas
    for (let house of this.houses) {
      house.display(this.buffer, this.minX, this.minY);
    }
  }

  // Método para dibujar el polígono
  display() {
    // Actualizar el buffer si es necesario
    if ((frameCount + this.fundacion) % 60 === 0 && this.populationChanged) {
      this.updateBuffer();
      this.populationChanged = false;
    }

    // Mostrar el buffer
    image(this.buffer, this.minX, this.minY);

    // Si el polígono está seleccionado, dibujar el borde especial
    if (this.selected) {
      noFill();
      strokeWeight(9);
      let t = (sin(frameCount * 0.07) + 1) / 2; // Oscila entre 0 y 1
      let colorOscilante = lerpColor(color(0), color(red(this.color), green(this.color), blue(this.color)), t);
      stroke(colorOscilante);

      beginShape();
      for (let point of this.points) {
        vertex(point.X, point.Y);
      }
      endShape(CLOSE);
    }
  }


  
  // Método para calcular el área del polígono
  getArea() {
    return Math.abs( calculateArea(this.points));
  }

  // Método privado para calcular el área
  

  // Método para asegurar que el polígono tiene orientación clockwise
  ensureClockwise() {
    if ( calculateArea(this.points) > 0) {
      this.points.reverse();
    }
  }

  // Método para generar los caminos internos (líneas paralelas a un segmento base)
  generateRoads() {
    // Seleccionar un segmento base aleatorio
    if (this.points.length < 2) return;
    let index = floor(random(this.points.length));
    let baseSegment = {
      start: this.points[index],
      end: this.points[(index + 1) % this.points.length],
    };

    // Calcular vector dirección del segmento base
    let dir = {
      X: baseSegment.end.X - baseSegment.start.X,
      Y: baseSegment.end.Y - baseSegment.start.Y,
    };

    // Normalizar el vector
    let mag = Math.hypot(dir.X, dir.Y);
    dir.X /= mag;
    dir.Y /= mag;

    // Calcular el vector normal (perpendicular) al segmento base
    let normal = {
      X: -dir.Y,
      Y: dir.X,
    };

    // Calcular límites del bounding box del polígono
    let minX = Math.min(...this.points.map(p => p.X));
    let maxX = Math.max(...this.points.map(p => p.X));
    let minY = Math.min(...this.points.map(p => p.Y));
    let maxY = Math.max(...this.points.map(p => p.Y));

    // Calcular centro del bounding box
    let centerX = (minX + maxX) / 2;
    let centerY = (minY + maxY) / 2;

    // Calcular la diagonal para determinar el número de líneas necesarias
    let diagonal = Math.hypot(maxX - minX, maxY - minY);
    let numLines = Math.ceil(diagonal / this.spacing);

    // Generar líneas paralelas al segmento base
    for (let i = -numLines; i <= numLines; i++) {
      let offset = i * this.spacing;
      let lineStart = {
        X: centerX + normal.X * offset - dir.X * 3000,
        Y: centerY + normal.Y * offset - dir.Y * 3000,
      };
      let lineEnd = {
        X: centerX + normal.X * offset + dir.X * 3000,
        Y: centerY + normal.Y * offset + dir.Y * 3000,
      };

      // Intersecar la línea con el polígono
      let clipper = new ClipperLib.Clipper();
      let subj = [[lineStart, lineEnd]]; // Línea como sujeto (open path)
      let clp = [this.points]; // Polígono como clip (closed path)

      let solution = new ClipperLib.PolyTree();

      clipper.AddPaths(subj, ClipperLib.PolyType.ptSubject, false); // false para open path
      clipper.AddPaths(clp, ClipperLib.PolyType.ptClip, true); // true para closed path

      // Ejecutar la operación de intersección
      let succeeded = clipper.Execute(
        ClipperLib.ClipType.ctIntersection,
        solution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
      );

      // Si hay intersección, extraer los caminos abiertos resultantes
      if (succeeded) {
        let openPaths = ClipperLib.Clipper.OpenPathsFromPolyTree(solution);
        for (let path of openPaths) {
          if (path.length >= 2) {
            this.roads.push({
              start: path[0],
              end: path[path.length - 1],
            });
          }
        }
      }
    }
  }

  // Método para verificar si un punto está dentro del polígono
  containsPoint(x, y) {
    let inside = false;
    let n = this.points.length;
    for (let i = 0, j = n - 1; i < n; j = i++) {
      let xi = this.points[i].X, yi = this.points[i].Y;
      let xj = this.points[j].X, yj = this.points[j].Y;

      let intersect = ((yi > y) !== (yj > y)) &&
                      (x < (xj - xi) * (y - yi) / (yj - yi + 0.0000001) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Método para intentar generar una casa
    // Método para intentar generar una casa
  // Método para intentar generar una casa
  generateHouse() {
    // Definir la frecuencia y chance de generar una casa
    let chance = 0.99; // 99% de chance cada vez que se llama
    if (random() > chance) return;

    // Seleccionar aleatoriamente si la casa se genera en un camino o en el borde
    let isOnRoad = random() < 0.5;

    let targetSegments = isOnRoad ? this.roads : this.getBoundarySegments();

    if (targetSegments.length === 0) return;

    // Seleccionar una carretera o un segmento del borde aleatoriamente
    let segment = random(targetSegments);

    // Seleccionar una posición aleatoria a lo largo del segmento
    let t = random(); // 0 a 1
    let entryPoint = {
      X: lerp(segment.start.X, segment.end.X, t),
      Y: lerp(segment.start.Y, segment.end.Y, t)
    };

    // Definir el ancho de la entrada
    let entryWidth = 10;
    let lado = random() > 0.5 ? (isOnRoad ? 1 : -1) : -1;

    // Calcular el vector dirección del segmento base
    let dir = {
      X: lado * (segment.end.X - segment.start.X),
      Y: lado * (segment.end.Y - segment.start.Y),
    };

    // Normalizar el vector
    let mag = Math.hypot(dir.X, dir.Y);
    if (mag === 0) return; // evitar división por cero
    dir.X /= mag;
    dir.Y /= mag;

    // Calcular el vector normal (perpendicular) al segmento base
    let normal = {
      X: -dir.Y,
      Y: dir.X,
    };

    // Definir los dos puntos de la entrada (centro +/- half entryWidth)
    let halfWidth = entryWidth / 2;
    let entryStart = {
      X: entryPoint.X - normal.X * halfWidth,
      Y: entryPoint.Y - normal.Y * halfWidth,
    };
    let entryEnd = {
      X: entryPoint.X + normal.X * halfWidth,
      Y: entryPoint.Y + normal.Y * halfWidth,
    };

    // Definir el tamaño de la casa
    let houseWidth = entryWidth;
    let houseHeight = random(entryWidth, this.spacing *this.lenPatio);

    // Definir la separación entre la entrada y el camino/borde
    let separation = 5; // píxeles

    // Calcular la posición de la casa: desplazada desde la entrada hacia el interior usando el vector normal
    let housePos = {
      X: entryPoint.X + normal.X * separation,
      Y: entryPoint.Y + normal.Y * separation,
    };

    // Definir los puntos de la casa (rectángulo)
    let housePoints = [
      { X: housePos.X, Y: housePos.Y },
      { X: housePos.X + dir.X * houseWidth, Y: housePos.Y + dir.Y * houseWidth },
      { X: housePos.X + dir.X * houseWidth + normal.X * houseHeight, Y: housePos.Y + dir.Y * houseWidth + normal.Y * houseHeight },
      { X: housePos.X + normal.X * houseHeight, Y: housePos.Y + normal.Y * houseHeight }
    ];

    // Calcular el área original de la casa propuesta
    let originalArea = calculateArea(housePoints);
  
    // Crear una instancia de House
    let house = new House(housePoints);

    // Clipper para asegurar que la casa está dentro del polígono
    let clipper = new ClipperLib.Clipper();
    let subj = [house.points]; // Casa como sujeto
    let clp = [this.points]; // Polígono como clip

    let solution = new ClipperLib.Paths();

    clipper.AddPaths(subj, ClipperLib.PolyType.ptSubject, true); // true para closed path
    clipper.AddPaths(clp, ClipperLib.PolyType.ptClip, true); // true para closed path

    // Ejecutar la operación de intersección
    let succeeded = clipper.Execute(
      ClipperLib.ClipType.ctIntersection,
      solution,
      ClipperLib.PolyFillType.pftNonZero,
      ClipperLib.PolyFillType.pftNonZero
    );

    if (!succeeded || solution.length === 0) return;

    // Usar el primer path como la casa recortada
    let clippedHouse = solution[0];

    // Calcular el área después de recortar con el polígono
    let clippedArea = calculateArea(clippedHouse);

    // Verificar si el área es al menos el 30% del área original
    if (clippedArea < this.densidad * originalArea) return;

    // Ahora, bufferizar carreteras y bordes
    let bufferDistance = separation; // 5 píxeles

    let roadBuffers = [];
    let boundaryBuffers = [];

    // Bufferizar carreteras (ambos lados)
    for (let road of this.roads) {
      // Definir el ancho del buffer
      let roadWidth = 2 * bufferDistance; // Ancho total del buffer

      // Calcular el vector normalizado para el camino
      let roadDir = {
        X: road.end.X - road.start.X,
        Y: road.end.Y - road.start.Y
      };
      let roadMag = Math.hypot(roadDir.X, roadDir.Y);
      if (roadMag === 0) continue; // Evitar división por cero
      roadDir.X /= roadMag;
      roadDir.Y /= roadMag;

      let roadNormal = {
        X: -roadDir.Y,
        Y: roadDir.X
      };

      // Definir los cuatro puntos del rectángulo bufferizado
      let bufferPoints = [
        movePoint(road.start, roadNormal, bufferDistance),
        movePoint(road.end, roadNormal, bufferDistance),
        movePoint(road.end, roadNormal, -bufferDistance),
        movePoint(road.start, roadNormal, -bufferDistance)
      ];

      roadBuffers.push(bufferPoints);
    }

    // Bufferizar bordes de la localidad (solo hacia el interior)
    for (let boundary of this.getBoundarySegments()) {
      // Definir la distancia del buffer
      let boundaryBufferDistance = bufferDistance; // 5 píxeles

      // Calcular el vector normalizado para el borde
      let boundaryDir = {
        X: boundary.end.X - boundary.start.X,
        Y: boundary.end.Y - boundary.start.Y
      };
      let boundaryMag = Math.hypot(boundaryDir.X, boundaryDir.Y);
      if (boundaryMag === 0) continue; // Evitar división por cero
      boundaryDir.X /= boundaryMag;
      boundaryDir.Y /= boundaryMag;

      let boundaryNormal = {
        X: -boundaryDir.Y,
        Y: boundaryDir.X
      };

      // Definir los dos puntos de la entrada desplazados hacia el interior
      let bufferStart = movePoint(boundary.start, boundaryNormal, boundaryBufferDistance);
      let bufferEnd = movePoint(boundary.end, boundaryNormal, boundaryBufferDistance);

      // Definir el polígono del buffer (narrow rectangle hacia el interior)
      let bufferPolygon = [
        bufferStart,
        bufferEnd,
        movePoint(bufferEnd, boundaryDir, 1), // Pequeño desplazamiento para cerrar el polígono
        movePoint(bufferStart, boundaryDir, 1)
      ];

      boundaryBuffers.push(bufferPolygon);
    }

    // Combinar buffers de carreteras y bordes
    let totalBuffers = roadBuffers.concat(boundaryBuffers);

    // Crear una instancia de Clipper para ajustar la casa
    let clipperHouse = new ClipperLib.Clipper();

    // Agregar la casa recortada como sujeto
    clipperHouse.AddPaths([clippedHouse], ClipperLib.PolyType.ptSubject, true);

    // Agregar los buffers como clip
    clipperHouse.AddPaths(totalBuffers, ClipperLib.PolyType.ptClip, true);

    // Definir la solución
    let houseAdjusted = new ClipperLib.Paths();

    // Ejecutar la operación de diferencia: casa - buffers
    let succeededSubtract = clipperHouse.Execute(
      ClipperLib.ClipType.ctDifference,
      houseAdjusted,
      ClipperLib.PolyFillType.pftNonZero,
      ClipperLib.PolyFillType.pftNonZero
    );

    if (!succeededSubtract || houseAdjusted.length === 0) return;

    // Usar el primer path como la casa ajustada
    let adjustedHouse = houseAdjusted[0];

    // Calcular el área después de ajustar con buffers
    let adjustedArea = calculateArea(adjustedHouse);

    // Verificar si el área es al menos el 30% del área original
    if (adjustedArea < this.densidad * originalArea) return;

    // Ahora, considerar la intersección con casas existentes
    let finalHouse = adjustedHouse;

    // Substraer casas existentes del polígono de la casa propuesta
    for (let existingHouse of this.houses) {
      let clipperSubtract = new ClipperLib.Clipper();

      // Agregar la casa actual como sujeto
      clipperSubtract.AddPath(finalHouse, ClipperLib.PolyType.ptSubject, true);

      // Agregar la casa existente como clip
      clipperSubtract.AddPath(existingHouse.getPolygon(), ClipperLib.PolyType.ptClip, true);

      // Definir la solución
      let subtractSolution = new ClipperLib.Paths();

      // Ejecutar la operación de diferencia
      let succeededSubtract = clipperSubtract.Execute(
        ClipperLib.ClipType.ctDifference,
        subtractSolution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
      );

      if (succeededSubtract && subtractSolution.length > 0) {
        // Usar el primer path como la casa resultante
        finalHouse = subtractSolution[0];
      } else {
        // Si la casa fue completamente solapada, descartarla
        finalHouse = null;
        break;
      }
    }

    if (!finalHouse || finalHouse.length < 3) {
      // La casa fue completamente solapada o es inválida
      return;
    }

    // Calcular el área después de considerar casas existentes
    let finalArea = calculateArea(finalHouse);

    // Verificar si el área es al menos el 30% del área original
    if (finalArea < this.densidad * originalArea) return;

    // Crear la casa con el polígono final
    let newHouse = new House(finalHouse);

    // Agregar la casa a la lista
    this.houses.push(newHouse);

    // Aumentar la población de la localidad
    this.population += floor(random(1, 6)); // entre 1 y 5

    // Marcar que la población cambió
    this.populationChanged = true;
  }

  // Método para obtener los segmentos del borde (sin contar roads)
  getBoundarySegments() {
    let segments = [];
    let n = this.points.length;
    for (let i = 0; i < n; i++) {
      segments.push({
        start: this.points[i],
        end: this.points[(i + 1) % n],
      });
    }
    return segments;
  }
}
function calculateArea(points) {
    let area = 0;
    let n = points.length;
    for (let i = 0; i < n; i++) {
      let j = (i + 1) % n;
      area += points[i].X * points[j].Y;
      area -= points[j].X * points[i].Y;
    }
    return area / 2;
  }

function movePoint(point, normal, distance) {
  return {
    X: point.X + normal.X * distance,
    Y: point.Y + normal.Y * distance
  };
}


// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\road.js
class Road {
    constructor(points) {
      this.points = points;
      this.color = color(100); // Color del camino
      this.selected = false;
    }
  
    display() {
      fill(this.color);
      stroke(0);
      strokeWeight(1);
      beginShape();
      for (let point of this.points) {
        vertex(point.X, point.Y);
      }
      endShape(CLOSE);
  
      if (this.selected) {
        noFill();
        strokeWeight(3);
        stroke(255, 0, 0);
        beginShape();
        for (let point of this.points) {
          vertex(point.X, point.Y);
        }
        endShape(CLOSE);
      }
    }
  
    containsPoint(x, y) {
      let inside = false;
      let n = this.points.length;
      for (let i = 0, j = n - 1; i < n; j = i++) {
        let xi = this.points[i].X, yi = this.points[i].Y;
        let xj = this.points[j].X, yj = this.points[j].Y;
  
        let intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi + 0.0000001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
  }

// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\sketch.js
// sketch.js

// Lista de polígonos completados
let polygons = [];
let roads = [];
// Puntos del polígono en curso
let currentPoints = [];

// Estado de dibujo
let isDrawing = false;

// Tolerancia para cerrar el polígono (en píxeles)
let tolerance = 20;
let thickness = 4; // Grosor del camino
// Color del polígono actual
let currentColor;

// Polígono seleccionado
let selectedPolygon = null;

// Frecuencia de generación de casas (cada X frames)
let houseGenerationFrequency = 1; // Por ejemplo, cada 60 frames (~1 segundo a 60fps)

let grid;
let cellSize = 15; // Tamaño de cada celda
let offsetX = 0; // Desplazamiento en X para arrastrar
let offsetY = 0; // Desplazamiento en Y para arrastrar
let noiseScale = 0.01;
let dragging = false;
let minH = -2000;
let maxH = 3000;
let previousMouse;


function setup() {
   createCanvas(1200, 800);
  // Activar el loop de dibujo
  loop();
  
  // Prevenir el menú contextual en clic derecho
  canvas.addEventListener('contextmenu', function(event) {
    event.preventDefault();
  });

  // Configura una semilla para el ruido Perlin para consistencia
  noiseSeed(66); // Puedes cambiar este valor para obtener diferentes terrenos

  // Inicializar la grilla
  grid = new Grid(cellSize);
  
  // Generar las celdas visibles inicialmente
  grid.generateCellsInView(offsetX, offsetY, width, height);
  ui = new UI();
}

function draw() {
  background(44, 77, 190);
  
  push();
  translate(offsetX, offsetY);
  grid.display();
  
  // Dibujar todos los polígonos existentes
  for (let poly of polygons) {
    poly.display(); // Usar el método draw actualizado de Polygon
  }

  // Dibujar el polígono en curso si está siendo dibujado
  if (isDrawing && currentPoints.length > 0) {
    drawCurrentPolygon(currentPoints, color(0, 255, 0, 100));
  }
// Dibujar todos los caminos existentes
for (let road of roads) {
  road.display();
}

// Dibujar el polígono o camino en curso
if (isDrawing && currentPoints.length > 0) {
  if (ui.herramienta === 0) {
    drawCurrentPolygon(currentPoints, color(0, 255, 0, 100));
  } else if (ui.herramienta === 1) {
    drawCurrentPolyline(currentPoints, color(255, 0, 0, 100));
  }
}
  // Mostrar detalles del polígono seleccionado
  if (selectedPolygon) {
    fill(11);
    noStroke();
    textSize(16); 
    let infoX = 10 - offsetX;
    let infoY = height - 70 - offsetY;
    text("Detalles del objeto seleccionado:", infoX, infoY);
    if (selectedPolygon instanceof Polygon) {
      text("Tipo: Localidad", infoX, infoY + 20);
      text("Nombre: " + selectedPolygon.name, infoX, infoY + 40);
      text("Población: " + selectedPolygon.population, infoX, infoY + 60);
      text("Área: " + selectedPolygon.getArea().toFixed(2), infoX, infoY + 80);
    } else if (selectedPolygon instanceof Road) {
      text("Tipo: Camino", infoX, infoY + 20);
      // Agregar más detalles si es necesario
    }
  }

  // Generar casas cada X frames
  if (frameCount % houseGenerationFrequency === 0) {
    for (let poly of polygons) {
      poly.generateHouse();
    }
  } 
  pop();
}


// Manejar el evento de clic del mouse
function mousePressed() {
  if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {
    return false;
  }
  
  let x = mouseX - offsetX;
  let y = mouseY - offsetY;

  if (mouseButton === LEFT) {
    if (ui.herramienta === 0) {
      // Herramienta "Crear localidad"
      if (isDrawing && currentPoints.length > 2) {
        let d = dist(x, y, currentPoints[0].X, currentPoints[0].Y);
        if (d < tolerance) {
          closePolygon();
          return false;
        }
      }
      currentPoints.push({ X: x, Y: y });
      isDrawing = true;
      redraw();
    } else if (ui.herramienta === 1) {
      // Herramienta "Crear Camino"
      if (isDrawing && currentPoints.length > 1) {
        let d = dist(x, y, currentPoints[currentPoints.length - 1].X, currentPoints[currentPoints.length - 1].Y);
        if (d < tolerance) {
          closePolygon();
          return false;
        }
      }
      currentPoints.push({ X: x, Y: y });
      isDrawing = true;
      redraw();
    }
  } else if (mouseButton === RIGHT) {
    // Manejar selección con clic derecho
    let found = false;
    for (let poly of polygons) {
      if (poly.containsPoint(x, y)) {
        if (selectedPolygon && selectedPolygon !== poly) {
          selectedPolygon.selected = false;
        }
        selectedPolygon = poly;
        poly.selected = true;
        found = true;
        break;
      }
    }
    if (!found) {
      for (let road of roads) {
        if (road.containsPoint(x, y)) {
          if (selectedPolygon && selectedPolygon !== road) {
            selectedPolygon.selected = false;
          }
          selectedPolygon = road;
          road.selected = true;
          found = true;
          break;
        }
      }
    }
    if (!found && selectedPolygon) {
      selectedPolygon.selected = false;
      selectedPolygon = null;
    }
    redraw();
    return false;
  }
  if (mouseButton === CENTER) {
    dragging = true;
    previousMouse = createVector(mouseX, mouseY);
  }
}

function mouseDragged() {
  if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {
    return false;
  }
  if (dragging && mouseButton === CENTER) {
    let currentMouse = createVector(mouseX, mouseY);
    offsetX += currentMouse.x - previousMouse.x;
    offsetY += currentMouse.y - previousMouse.y;
    previousMouse = currentMouse;

    // Genera nuevas celdas y limpia las fuera de vista
    grid.generateCellsInView(offsetX, offsetY, width, height);
  }
}

function mouseReleased() {
  if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {
    return false;
  }
  if (mouseButton === CENTER) {
    dragging = false;
  }
}

// Cerrar y procesar el polígono actual
function closePolygon() {
  if (ui.herramienta === 0) {
    // Herramienta "Crear localidad"
    currentColor = color(random(255), random(255), random(255), 100);
    let newPolygon = new Polygon(currentPoints, currentColor);

    if (polygons.length > 0 || roads.length > 0) {
      let clipper = new ClipperLib.Clipper();

      let subj = [newPolygon.points];
      let existingPolygons = [];
      for (let poly of polygons) {
        existingPolygons.push(poly.points);
      }
      for (let road of roads) {
        existingPolygons.push(road.points);
      }

      clipper.AddPaths(existingPolygons, ClipperLib.PolyType.ptClip, true);
      clipper.AddPaths(subj, ClipperLib.PolyType.ptSubject, true);

      let solution = new ClipperLib.Paths();

      let succeeded = clipper.Execute(
        ClipperLib.ClipType.ctDifference,
        solution,
        ClipperLib.PolyFillType.pftNonZero,
        ClipperLib.PolyFillType.pftNonZero
      );

      if (succeeded && solution.length > 0) {
        for (let path of solution) {
          let polyColor = color(random(255), random(255), random(255), 100);
          let newPoly = new Polygon(path, polyColor);
          polygons.push(newPoly);
        }
      }
    } else {
      polygons.push(newPolygon);
    }
  } else if (ui.herramienta === 1) {
    // Herramienta "Crear Camino"
    

    let co = new ClipperLib.ClipperOffset();
    co.AddPath(currentPoints, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etOpenButt);
    let offsetPaths = new ClipperLib.Paths();
    co.Execute(offsetPaths, thickness);

    if (offsetPaths.length > 0) {
      let roadPath = offsetPaths[0];
      let newRoad = new Road(roadPath);

      if (polygons.length > 0 || roads.length > 0) {
        let clipper = new ClipperLib.Clipper();

        let subj = [newRoad.points];
        let existingPolygons = [];
        for (let poly of polygons) {
          existingPolygons.push(poly.points);
        }
        for (let road of roads) {
          existingPolygons.push(road.points);
        }

        clipper.AddPaths(existingPolygons, ClipperLib.PolyType.ptClip, true);
        clipper.AddPaths(subj, ClipperLib.PolyType.ptSubject, true);

        let solution = new ClipperLib.Paths();

        let succeeded = clipper.Execute(
          ClipperLib.ClipType.ctDifference,
          solution,
          ClipperLib.PolyFillType.pftNonZero,
          ClipperLib.PolyFillType.pftNonZero
        );

        if (succeeded && solution.length > 0) {
          for (let path of solution) {
            let newRoad = new Road(path);
            roads.push(newRoad);
          }
        }
      } else {
        roads.push(newRoad);
      }
    }
  }

  currentPoints = [];
  isDrawing = false;
  redraw();
}

// Función para dibujar el polígono en curso con el círculo en el primer vértice
function drawCurrentPolygon(points, colorFill) {
  fill(colorFill);
  strokeWeight(2)
  stroke(0);
  beginShape();
  for (let point of points) {
    vertex(point.X, point.Y);
  }
  endShape();

  // Dibujar un círculo rojo en el primer vértice para facilitar el cierre
  if (points.length > 0) {
    noStroke();
    fill(255, 0, 0);
    ellipse(points[0].X, points[0].Y, 10, 10);
  }
}
function drawCurrentPolyline(points, colorStroke) {
  noFill();
  stroke(colorStroke);
  strokeWeight(2);
  beginShape();
  for (let point of points) {
    vertex(point.X, point.Y);
  }
  endShape();
}
// Manejar la presión de teclas
function keyPressed() {
  if (key === 'r' || key === 'R') {
    polygons = [];
    roads = [];
    currentPoints = [];
    isDrawing = false;
    selectedPolygon = null;
    redraw();
  }
}


// Contenido del archivo: C:\Users\zelde\OneDrive\Documentos\REPOS\p5_sketches\p5sketches\docs\memoriapolis_mini\ui.js
class UI {
    constructor() {
        this.herramienta = 0;

        this.herramientaButton = createButton("Crear localidad");
        this.generateUI();
    }

    generateUI() {

        this.herramientaButton.position(width+10, 10);
        this.herramientaButton.mousePressed(() => {
            this.herramienta = (this.herramienta + 1) % 2;
            let nom = this.herramienta === 1 ? "Crear Camino" :"Crear localidad";
            console.log(nom);
            this.herramientaButton.html(nom);
          });
    }

}

